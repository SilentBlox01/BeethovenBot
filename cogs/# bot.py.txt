# bot.py
import os
import logging
import random
import asyncio
from datetime import datetime

import discord
from discord.ext import commands, tasks
from discord import app_commands
from discord.ui import View, Button, Select

import aiosqlite
import aiohttp
import qrcode
import sympy
from sympy import sin, cos, tan, log, ln, sqrt, pi, E, Pow
from dotenv import load_dotenv
# keep_alive import left as-is if you're using Replit/uptime services
try:
    from keep_alive import keep_alive
except Exception:
    keep_alive = lambda: None

# ====== CONFIG & LOGGING ======
load_dotenv()
TOKEN = os.getenv("TOKEN") or os.environ.get("TOKEN")
if not TOKEN:
    raise RuntimeError("TOKEN no encontrado en variables de entorno.")

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger("BeethovenBot")

DB_PATH = "bot.db"

# ====== INTENTS ======
intents = discord.Intents.default()
intents.message_content = True
intents.members = True  # solo si necesitas miembros; desactiva si no
bot = commands.Bot(command_prefix=None, intents=intents, case_insensitive=True, help_command=None)

# ====== GLOBAL RESOURCES ======
http_session: aiohttp.ClientSession | None = None
# Cach√©s en memoria (evitan I/O constante)
CACHE = {
    "blacklist": set(),
    "afk": {},  # user_id -> reason
}

# ====== UTIL: DB (aiosqlite) ======
async def init_db():
    """Crea tablas si no existen y carga caches en memoria."""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            CREATE TABLE IF NOT EXISTS afk_users (
                id_usuario INTEGER PRIMARY KEY,
                razon TEXT
            )
        """)
        await db.execute("""
            CREATE TABLE IF NOT EXISTS blacklist (
                user_id TEXT PRIMARY KEY
            )
        """)
        await db.commit()
        logger.info("Base de datos inicializada.")

    # Cargar caches
    await load_caches()

async def load_caches():
    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute("SELECT user_id FROM blacklist") as cursor:
            rows = await cursor.fetchall()
            CACHE["blacklist"] = set(r[0] for r in rows)
        async with db.execute("SELECT id_usuario, razon FROM afk_users") as cursor:
            rows = await cursor.fetchall()
            CACHE["afk"] = {int(r[0]): r[1] for r in rows}
    logger.info(f"Caches cargadas: blacklist={len(CACHE['blacklist'])}, afk={len(CACHE['afk'])}")

async def add_blacklist(user_id: int):
    uid = str(user_id)
    if uid in CACHE["blacklist"]:
        return False
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT OR IGNORE INTO blacklist (user_id) VALUES (?)", (uid,))
        await db.commit()
    CACHE["blacklist"].add(uid)
    return True

async def remove_blacklist(user_id: int):
    uid = str(user_id)
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("DELETE FROM blacklist WHERE user_id = ?", (uid,))
        await db.commit()
    removed = uid in CACHE["blacklist"]
    CACHE["blacklist"].discard(uid)
    return removed

async def set_afk(user_id: int, reason: str):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT OR REPLACE INTO afk_users (id_usuario, razon) VALUES (?, ?)", (user_id, reason))
        await db.commit()
    CACHE["afk"][int(user_id)] = reason

async def remove_afk(user_id: int):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("DELETE FROM afk_users WHERE id_usuario = ?", (user_id,))
        await db.commit()
    CACHE["afk"].pop(int(user_id), None)

# ====== STARTUP / SHUTDOWN ======
@bot.event
async def on_ready():
    global http_session
    logger.info(f"{bot.user} is online - {datetime.utcnow().isoformat()}")
    if http_session is None:
        http_session = aiohttp.ClientSession()
    await init_db()
    # Fuerza la sincronizaci√≥n global de comandos
    synced = await bot.tree.sync()
    logger.info(f"Comandos sincronizados: {[cmd.name for cmd in synced]}")
    await bot.change_presence(status=discord.Status.online, activity=discord.Game("/help"))
    logger.info("Bot listo y sincronizado con comandos de aplicaci√≥n.")

    if "help" in bot.all_commands:
        bot.remove_command("help")

@bot.event
async def on_close():
    global http_session
    if http_session:
        await http_session.close()

# ====== HELPERS ======
async def fetch_json(url: str, timeout: int = 10):
    """GET JSON usando session compartida."""
    global http_session
    if http_session is None:
        http_session = aiohttp.ClientSession()
    try:
        async with http_session.get(url, timeout=timeout) as resp:
            resp.raise_for_status()
            return await resp.json()
    except Exception as e:
        logger.error(f"HTTP GET error: {url} - {e}")
        return None

def make_embed(title: str, description: str | None = None, color: int = 0x2F3136):
    e = discord.Embed(title=title, description=description or "", color=color)
    e.timestamp = datetime.utcnow()
    return e

@bot.tree.command(name="ban", description="Banea a un miembro del servidor.")
@app_commands.describe(member="El miembro a banear", reason="La raz√≥n del ban (opcional)")
@app_commands.checks.has_permissions(ban_members=True)
async def ban(interaction: discord.Interaction, member: discord.Member, reason: str = "Sin raz√≥n establecida."):
    try:
        await member.ban(reason=reason)
        await interaction.response.send_message(f"{member.mention} fue baneado por {interaction.user.mention} por {reason}.")
        logger.info(f"Usuario {member.id} baneado por {interaction.user.id}")
    except Exception as e:
        await interaction.response.send_message(f"Error al banear: {str(e)}", ephemeral=True)
        logger.error(f"Error en ban: {str(e)}")

@bot.tree.command(name="kick", description="Expulsa a un miembro del servidor.")
@app_commands.describe(member="El miembro a expulsar", reason="La raz√≥n del kick (opcional)")
@app_commands.checks.has_permissions(kick_members=True)
async def kick(interaction: discord.Interaction, member: discord.Member, reason: str = "Sin raz√≥n establecida."):
    try:
        await member.kick(reason=reason)
        await interaction.response.send_message(f"{member.mention} fue expulsado por {interaction.user.mention} por {reason}.")
        logger.info(f"Usuario {member.id} expulsado por {interaction.user.id}")
    except Exception as e:
        await interaction.response.send_message(f"Error al expulsar: {str(e)}", ephemeral=True)
        logger.error(f"Error en kick: {str(e)}")

@bot.tree.command(name="unban", description="Revoca el ban de un usuario.")
@app_commands.describe(user_id="El ID del usuario a desbanear")
@app_commands.checks.has_permissions(ban_members=True)
async def unban(interaction: discord.Interaction, user_id: str):
    try:
        user = await bot.fetch_user(int(user_id))
        await interaction.guild.unban(user)
        await interaction.response.send_message(f"{user.mention} fue desbaneado por {interaction.user.mention}.")
        logger.info(f"Usuario {user_id} desbaneado por {interaction.user.id}")
    except Exception as e:
        await interaction.response.send_message(f"Error al desbanear: {str(e)}", ephemeral=True)
        logger.error(f"Error en unban: {str(e)}")


@bot.tree.command(name="blacklistadd", description="A√±ade un usuario a la lista negra.")
@app_commands.describe(user_id="El ID del usuario")
@app_commands.checks.has_permissions(administrator=True)
async def blacklistadd(interaction: discord.Interaction, user_id: str):
    try:
        user_id_int = int(user_id)
        if await add_blacklist(user_id_int):
            await interaction.response.send_message(f"El usuario `{user_id}` ha sido a√±adido a la lista negra.")
            logger.info(f"Usuario {user_id} a√±adido a blacklist por {interaction.user.id}")
        else:
            await interaction.response.send_message(f"El usuario `{user_id}` ya estaba en la lista negra.", ephemeral=True)
    except ValueError:
        await interaction.response.send_message("Por favor, introduce un ID de usuario v√°lido.", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"Error al a√±adir a la lista negra: {e}", ephemeral=True)

@bot.tree.command(name="blacklistremove", description="Elimina un usuario de la lista negra.")
@app_commands.describe(user_id="El ID del usuario")
@app_commands.checks.has_permissions(administrator=True)
async def blacklistremove(interaction: discord.Interaction, user_id: str):
    try:
        user_id_int = int(user_id)
        if await remove_blacklist(user_id_int):
            await interaction.response.send_message(f"El usuario `{user_id}` ha sido eliminado de la lista negra.")
            logger.info(f"Usuario {user_id} eliminado de blacklist por {interaction.user.id}")
        else:
            await interaction.response.send_message(f"El usuario `{user_id}` no se encontr√≥ en la lista negra.", ephemeral=True)
    except ValueError:
        await interaction.response.send_message("Por favor, introduce un ID de usuario v√°lido.", ephemeral=True)

@bot.tree.command(name="say", description="Haz que el bot diga lo que quieras.")
@app_commands.describe(text="El texto que quieres que el bot diga.")
@app_commands.checks.has_permissions(administrator=True)
async def say(interaction: discord.Interaction, text: str):
    await interaction.response.send_message("‚úÖ Mensaje enviado.", ephemeral=True)
    await interaction.channel.send(text)

# Manejo de error si el usuario no tiene permisos
@say.error
async def say_error(interaction: discord.Interaction, error):
    if isinstance(error, app_commands.MissingPermissions):
        await interaction.response.send_message(
            "üö´ No tienes permisos de administrador para usar este comando.",
            ephemeral=True
        )

@bot.tree.command(name="purge", description="Elimina mensajes del canal.")
@app_commands.describe(amount="Cantidad de mensajes a eliminar (1-100).")
@app_commands.checks.has_permissions(manage_messages=True)
async def purge(interaction: discord.Interaction, amount: int):
    if amount < 1 or amount > 100:
        await interaction.response.send_message(
            "üö´ Debes ingresar un n√∫mero entre 1 y 100.", ephemeral=True
        )
        return

    deleted = await interaction.channel.purge(limit=amount)
    await interaction.response.send_message(
        f"‚úÖ Se eliminaron {len(deleted)} mensajes.", ephemeral=True
    )

# Manejo de errores
@purge.error
async def purge_error(interaction: discord.Interaction, error):
    if isinstance(error, app_commands.MissingPermissions):
        await interaction.response.send_message(
            "üö´ No tienes permisos para administrar mensajes.",
            ephemeral=True
        )
    else:
        await interaction.response.send_message(
            f"‚ùå Ocurri√≥ un error: {error}",
            ephemeral=True
        )

@bot.tree.command(name="serverinfo", description="Muestra la informaci√≥n avanzada del servidor.")
@app_commands.checks.has_permissions(administrator=True)
async def serverinfo(interaction: discord.Interaction):
    guild = interaction.guild
    owner = guild.owner  # <-- corregido
    created_at = guild.created_at.strftime("%d/%m/%Y %H:%M:%S")
    humans = len([m for m in guild.members if not m.bot])
    bots = len([m for m in guild.members if m.bot])
    roles_count = len(guild.roles)
    channels_count = len(guild.channels)
    emojis_count = len(guild.emojis)
    verification = str(guild.verification_level).title()
    region = getattr(guild, "region", "Desconocida")
    icon_url = guild.icon.url if guild.icon else None

    embed = make_embed("Informaci√≥n del servidor", color=discord.Color.blurple().value)
    embed.set_thumbnail(url=icon_url)
    embed.add_field(name="Nombre", value=guild.name, inline=True)
    embed.add_field(name="ID", value=guild.id, inline=True)
    embed.add_field(name="Propietario", value=f"{owner} ({owner.id})", inline=True)
    embed.add_field(name="Creado el", value=created_at, inline=True)
    embed.add_field(name="Miembros", value=f"Total: {guild.member_count}\nHumanos: {humans}\nBots: {bots}", inline=True)
    embed.add_field(name="Roles", value=roles_count, inline=True)
    embed.add_field(name="Canales", value=channels_count, inline=True)
    embed.add_field(name="Emojis", value=emojis_count, inline=True)
    embed.add_field(name="Nivel de verificaci√≥n", value=verification, inline=True)
    embed.add_field(name="Regi√≥n", value=region, inline=True)
    embed.add_field(name="Pedido por", value=interaction.user.mention, inline=False)
    embed.set_footer(text="Creado con amor")
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="userinfo", description="Consigue informaci√≥n de un usuario.")
@app_commands.describe(member="El miembro a consultar (opcional, por defecto t√∫)")
async def userinfo(interaction: discord.Interaction, member: discord.Member | None = None):
    member = member or interaction.user
    if member == bot.user:
        await interaction.response.send_message("¬øQu√© quieres saber? Si soy yo misma :D")
        return

    embed = make_embed(f"Info de {member}", color=0x00f549)
    embed.set_thumbnail(url=member.avatar.url if member.avatar else member.default_avatar.url)
    embed.add_field(name="Nombre de usuario", value=str(member), inline=True)
    embed.add_field(name="Apodo", value=member.display_name or "Ninguno", inline=True)
    embed.add_field(name="ID", value=member.id, inline=True)
    embed.add_field(name="Bot", value="S√≠" if member.bot else "No", inline=True)
    embed.add_field(name="Cuenta creada", value=member.created_at.strftime("%d/%m/%Y %H:%M:%S"), inline=True)
    if member.joined_at:
        embed.add_field(name="Ingres√≥ al servidor", value=member.joined_at.strftime("%d/%m/%Y %H:%M:%S"), inline=True)
    embed.add_field(name="Estado", value=getattr(member.status, "name", "Desconocido").title(), inline=True)
    activity = getattr(member.activity, "name", None) or "Ninguna"
    embed.add_field(name="Actividad", value=activity, inline=True)
    embed.add_field(name="Booster", value="S√≠" if member.premium_since else "No", inline=True)
    embed.add_field(name="AFK", value="S√≠" if member.id in CACHE["afk"] else "No", inline=True)

    # Roles (m√°ximo 10 para evitar embeds largos)
    roles = [r.mention for r in member.roles if not r.is_default()]
    if roles:
        roles_text = ", ".join(roles[:10])
        if len(roles) > 10:
            roles_text += f" y {len(roles)-10} m√°s..."
    else:
        roles_text = "Ninguno"
    embed.add_field(name="Roles", value=roles_text, inline=False)

    # Permisos principales
    perms = []
    if member.guild_permissions.administrator: perms.append("Administrador")
    if member.guild_permissions.manage_guild: perms.append("Gestiona servidor")
    if member.guild_permissions.ban_members: perms.append("Banear")
    if member.guild_permissions.kick_members: perms.append("Expulsar")
    if member.guild_permissions.manage_messages: perms.append("Gestiona mensajes")
    if member.guild_permissions.manage_roles: perms.append("Gestiona roles")
    if perms:
        embed.add_field(name="Permisos principales", value=", ".join(perms), inline=False)

    # Banner si existe
    try:
        user_obj = await interaction.client.fetch_user(member.id)
        if hasattr(user_obj, "banner") and user_obj.banner:
            embed.set_image(url=user_obj.banner.url)
    except Exception:
        pass

    embed.set_footer(text=f"Solicitado por {interaction.user}", icon_url=interaction.user.avatar.url if interaction.user.avatar else None)
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="avatar", description="Muestra el avatar de un usuario")
@app_commands.describe(member="El miembro (opcional, por defecto t√∫)")
async def avatar(interaction: discord.Interaction, member: discord.Member | None = None):
    member = member or interaction.user
    embed = make_embed(f"Avatar de {member}", color=discord.Color.purple().value)
    embed.set_image(url=member.avatar.url if member.avatar else member.default_avatar.url)
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="morse", description="Convierte un texto a c√≥digo Morse.")
@app_commands.describe(message="El mensaje a convertir")
async def morse(interaction: discord.Interaction, message: str):
    morse_code = { 'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.',
                   'g': '--.', 'h': '....', 'i': '..', 'j': '.---','k': '-.-', 'l': '.-..',
                   'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.',
                   's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-',
                   'y': '-.--', 'z': '--..', '0': '-----', '1': '.----', '2': '..---',
                   '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',
                   '8': '---..', '9': '----.', '.': '.-.-.-', ',': '--..--', '?': '..--..',
                   '!': '-.-.--', '-': '-....-', '/': '-..-.', '@': '.--.-.', '(': '-.--.',
                   ')': '-.--.-', ' ': '/'
                 }
    morse_message = ' '.join(morse_code.get(c, c) for c in message.lower())
    await interaction.response.send_message(morse_message)

@bot.tree.command(name="qr", description="Genera un c√≥digo QR a partir de un texto.")
@app_commands.describe(text="El texto para el QR")
async def qr_cmd(interaction: discord.Interaction, text: str):
    # genera qr en memoria y env√≠a (no escribe al disco)
    try:
        import io
        img = qrcode.make(text)
        buf = io.BytesIO()
        img.save(buf, format="PNG")
        buf.seek(0)
        file = discord.File(buf, filename="qr.png")
        await interaction.response.send_message(file=file)
    except Exception as e:
        await interaction.response.send_message(f"Error al generar QR: {e}", ephemeral=True)
        logger.exception("Error en QR")

class AdvancedCalcView(View):
    def __init__(self):
        super().__init__(timeout=300)
        self.expression = ""

        # M√°ximo 25 botones, asegurando que "=" est√© incluido
        buttons = [
            ["7","8","9","/","sin"],
            ["4","5","6","*","cos"],
            ["1","2","3","-","tan"],
            ["0",".","(","+",")"],
            ["C","^","‚àö","ln","="]  # 7 botones, total: 25
        ]

        total = 0
        for row_idx, row in enumerate(buttons):
            for btn in row:
                if total < 25:
                    self.add_item(AdvancedCalcButton(btn, self, row=row_idx))
                    total += 1

class AdvancedCalcButton(Button):
    def __init__(self, label, view: AdvancedCalcView, row: int = 0):
        super().__init__(label=label, style=discord.ButtonStyle.secondary, row=row)
        self.view_ref = view

    async def callback(self, interaction: discord.Interaction):
        expr = self.view_ref.expression

        if self.label == "C":
            self.view_ref.expression = ""
        elif self.label == "DEL":
            self.view_ref.expression = expr[:-1]
        elif self.label == "=":
            try:
                # Mapeamos funciones seguras
                allowed_symbols = {
                    "sin": sin, "cos": cos, "tan": tan,
                    "log": log, "ln": ln, "‚àö": sqrt,
                    "pi": pi, "e": E, "^": Pow
                }
                # Reemplazamos el s√≠mbolo ‚àö por sqrt() para sympy
                safe_expr = expr.replace("‚àö", "sqrt")
                safe_expr = safe_expr.replace("^", "**")
                result = sympy.sympify(safe_expr, locals=allowed_symbols).evalf()
                self.view_ref.expression = str(result)
            except Exception:
                self.view_ref.expression = "Error"
        else:
            self.view_ref.expression += self.label

        embed = discord.Embed(
            title="üßÆ Calculadora Cient√≠fica",
            description=f"```{self.view_ref.expression}```",
            color=discord.Color.blurple()
        )
        await interaction.response.edit_message(embed=embed, view=self.view_ref)

# Comando de barra para abrir la calculadora avanzada
@bot.tree.command(name="calc", description="Calculadora cient√≠fica avanzada")
async def calc(interaction: discord.Interaction):
    view = AdvancedCalcView()
    embed = discord.Embed(
        title="üßÆ Calculadora Cient√≠fica Avanzada",
        description="```0```",
        color=discord.Color.blurple()
    )
    await interaction.response.send_message(embed=embed, view=view, ephemeral=False)

# ====== AFK / MESSAGE HANDLING ======
@bot.tree.command(name="afk", description="Establece un estado de ausencia.")
@app_commands.describe(message="La raz√≥n de tu AFK (opcional)")
async def afk(interaction: discord.Interaction, message: str = ""):
    await set_afk(interaction.user.id, message)
    await interaction.response.send_message(f"{interaction.user.mention} est√° ahora AFK: {message}")
    logger.info(f"Usuario {interaction.user.id} establecido como AFK")

@bot.tree.command(name="unafk", description="Quita el estado de ausencia.")
async def unafk(interaction: discord.Interaction):
    await remove_afk(interaction.user.id)
    await interaction.response.send_message(f"{interaction.user.mention} ya no est√° AFK.")
    logger.info(f"Usuario {interaction.user.id} removido de AFK")

@bot.event
async def on_message(message: discord.Message):
    # evita bloquear con operaciones I/O sin await
    if message.author.bot:
        return

    # blacklist check (cache r√°pido)
    if str(message.author.id) in CACHE["blacklist"]:
        try:
            await message.channel.send(f"Lo siento, {message.author.mention}, est√°s en la lista negra.")
        except Exception:
            pass
        return

    # soporte para prefijo legacy m/afk (si prefieres mantenerlo)
    if message.content.startswith("m/afk "):
        razon = message.content[6:].strip()
        await set_afk(message.author.id, razon)
        await message.channel.send(f"{message.author.mention} est√° ahora AFK: {razon}")
        return

    # si el autor estaba en AFK, lo removemos
    if message.author.id in CACHE["afk"]:
        await remove_afk(message.author.id)
        await message.channel.send(f"{message.author.mention} ya no est√° AFK.")

    # avisar si mencionaron a alguien AFK
    if message.mentions:
        for m in message.mentions:
            if m.bot:
                continue
            reason = CACHE["afk"].get(int(m.id))
            if reason is not None:
                await message.channel.send(f"{message.author.mention}, {m.mention} est√° AFK: {reason}")

    # deja que discord.py procese comandos/registros de slash
    await bot.process_commands(message)



# ====== DIVERSION ======
@bot.tree.command(name="hello", description="El bot te saluda.")
async def hello(interaction: discord.Interaction):
    await interaction.response.send_message(f"Hola {interaction.user.mention}! ¬øQu√© tal?")

@bot.tree.command(name="bola8", description="Preg√∫ntale algo a la bola 8.")
@app_commands.describe(question="Tu pregunta")
async def bola8(interaction: discord.Interaction, question: str):
    responses = ["S√≠", "No", "Quiz√°s", "Probablemente", "No lo s√©", "Absolutamente", "Nunca", "Tal vez"]
    await interaction.response.send_message(f"üé± **Pregunta:** {question}\nüé± **Respuesta:** {random.choice(responses)}")

# RPS & Guess simplified (mismo comportamiento pero con async-safe waiters)
@bot.tree.command(name="rps", description="Juega piedra, papel o tijera con el bot.")
async def rps(interaction: discord.Interaction):
    emojis = ['ü™®', 'üìú', '‚úÇÔ∏è']
    results = ['Empate', 'Ganaste', 'Perdiste']

    def check_win(p1, p2):
        if p1 == p2:
            return results[0]
        win_conditions = {emojis[0]: emojis[2], emojis[1]: emojis[0], emojis[2]: emojis[1]}
        return results[1] if win_conditions[p1] == p2 else results[2]

    embed = discord.Embed(title="Piedra, Papel o Tijera", description="Reacciona para jugar:", color=discord.Color.green())
    embed.add_field(name="Piedra", value=emojis[0], inline=True)
    embed.add_field(name="Papel", value=emojis[1], inline=True)
    embed.add_field(name="Tijera", value=emojis[2], inline=True)

    await interaction.response.send_message(embed=embed)
    msg = await interaction.original_response()

    for emoji in emojis:
        await msg.add_reaction(emoji)

    def check(reaction, user):
        return user == interaction.user and str(reaction.emoji) in emojis and reaction.message.id == msg.id

    try:
        reaction, _ = await bot.wait_for('reaction_add', timeout=30.0, check=check)
    except asyncio.TimeoutError:
        await interaction.followup.send(f"{interaction.user.mention}, tiempo agotado.")
    else:
        bot_choice = random.choice(emojis)
        result = check_win(str(reaction.emoji), bot_choice)
        embed_result = discord.Embed(title="Resultado", color=discord.Color.green())
        embed_result.add_field(name="Tu elecci√≥n", value=str(reaction.emoji), inline=True)
        embed_result.add_field(name="Elecci√≥n del bot", value=bot_choice, inline=True)
        embed_result.add_field(name="Resultado", value=result, inline=True)
        await interaction.followup.send(embed=embed_result)

@bot.tree.command(name="guess", description="Adivina un n√∫mero del 1 al 50. Tienes varios intentos.")
@app_commands.describe(dificultad="Elige la dificultad: facil, medio, dificil")
async def guess(interaction: discord.Interaction, dificultad: str = "medio"):
    ranges = {"facil": 10, "medio": 30, "dificil": 50}
    max_num = ranges.get(dificultad.lower(), 30)
    num = random.randint(1, max_num)
    attempts = {"facil": 5, "medio": 7, "dificil": 10}.get(dificultad.lower(), 7)

    await interaction.response.send_message(f"¬°Adivina un n√∫mero del 1 al {max_num}! Tienes {attempts} intentos.")

    def check(msg):
        return msg.author == interaction.user and msg.channel == interaction.channel and msg.content.isdigit()

    for i in range(attempts):
        try:
            msg = await bot.wait_for('message', check=check, timeout=30)
            guess = int(msg.content)
        except asyncio.TimeoutError:
            await interaction.followup.send("‚è≥ Tiempo agotado.")
            return

        if guess == num:
            await interaction.followup.send(f"üéâ ¬°Felicidades {interaction.user.mention}! Adivinaste en {i+1} intentos.")
            return

        hint = "mayor" if guess < num else "menor"
        emoji_hint = "üî∫" if guess < num else "üîª"
        await interaction.followup.send(f"Mi n√∫mero es {hint} {emoji_hint}. Intenta de nuevo! ({attempts-i-1} intentos restantes)")

    await interaction.followup.send(f"üíÄ Agotaste todos los intentos. El n√∫mero era {num}.")

# ====== ANIME / IMAGENES ======
@bot.tree.command(name="aniinfo", description="Obt√©n informaci√≥n detallada de un anime.")
@app_commands.describe(anime_name="Nombre del anime a buscar")
async def aniinfo(interaction: discord.Interaction, anime_name: str):
    await interaction.response.defer()
    try:
        data = await fetch_json(f"https://api.jikan.moe/v4/anime?q={anime_name}&limit=1")
        results = data.get("data", [])
        if not results:
            await interaction.followup.send("‚ùå No encontr√© resultados.", ephemeral=True)
            return

        anime = results[0]
        synopsis = anime.get("synopsis", "Sin sinopsis disponible.") or "Sin sinopsis disponible."
        type_ = anime.get("type", "Desconocido")
        episodes = anime.get("episodes", "Desconocido")
        score = anime.get("score", "Desconocido")
        start_date = anime.get("aired", {}).get("from", "Desconocida")
        status = anime.get("status", "Desconocido")
        image_url = anime.get("images", {}).get("jpg", {}).get("image_url")

        # Truncar sinopsis si es muy larga
        if len(synopsis) > 300:
            synopsis = synopsis[:300] + "..."

        embed = discord.Embed(
            title=anime.get("title", "Desconocido"),
            url=anime.get("url"),
            description=synopsis,
            color=0x9208ea
        )
        embed.add_field(name="Tipo", value=type_, inline=True)
        embed.add_field(name="Episodios", value=episodes, inline=True)
        embed.add_field(name="Puntuaci√≥n", value=score, inline=True)
        embed.add_field(name="Fecha de estreno", value=start_date, inline=True)
        embed.add_field(name="Estado", value=status, inline=True)

        if image_url:
            embed.set_thumbnail(url=image_url)

        embed.set_footer(text=f"Solicitud de {interaction.user}", icon_url=interaction.user.avatar.url if interaction.user.avatar else None)
        await interaction.followup.send(embed=embed)

    except Exception as e:
        await interaction.followup.send(f"‚ùå Error al buscar anime: {str(e)}", ephemeral=True)
        logger.error(f"Error en aniinfo: {str(e)}")


# ------------------------ FUNCI√ìN PARA OBTENER IMAGEN ------------------------
async def fetch_waifu_image(action: str, nsfw: bool = False):
    """Obtiene una imagen de waifu.pics para la acci√≥n dada."""
    tipo = "nsfw" if nsfw else "sfw"
    url = f"https://api.waifu.pics/{tipo}/{action}"
    data = await fetch_json(url)
    if data and "url" in data:
        return data["url"]
    return None

# ------------------------ FUNCI√ìN PARA ENVIAR EMBED SFW ------------------------
async def send_action_embed(
    interaction: discord.Interaction,
    action_name: str,
    img_url: str,
    target: discord.Member | None = None,
    emoji: str = "",
):
    if not img_url:
        await interaction.followup.send("‚ùå Error al obtener imagen.", ephemeral=True)
        return

    description = (
        f"{interaction.user.mention} {action_name} {emoji}"
        if not target or target == interaction.user
        else f"{interaction.user.mention} {action_name} a {target.mention} {emoji}"
    )

    embed = discord.Embed(description=description, color=discord.Color.blurple())
    embed.set_image(url=img_url)

    await interaction.followup.send(embed=embed)


# ------------------------ FUNCI√ìN PARA ENVIAR EMBED NSFW ------------------------
async def send_nsfw_embed(
    interaction: discord.Interaction,
    action_text: str,
    img_url: str,
    target: discord.Member | None = None,
    emoji: str = "üîû",
):
    if not img_url:
        await interaction.followup.send("‚ùå No se pudo obtener imagen NSFW.", ephemeral=True)
        return

    description = (
        f"{interaction.user.mention} {action_text}"
        + (f" a {target.mention}" if target and target != interaction.user else "")
        + f" {emoji}"
    )

    embed = discord.Embed(description=description, color=discord.Color.dark_red())
    embed.set_image(url=img_url)
    embed.set_footer(text="üîû Contenido solo para mayores de edad.")

    await interaction.followup.send(embed=embed)


# ------------------------ COMANDOS SFW ------------------------
def setup_anime_commands(bot: commands.Bot):
    # --- Factory para comandos SFW ---
    def create_sfw_command(name: str, action: str, emoji: str):
        @app_commands.describe(target="Menciona a alguien (opcional)")
        async def _command(interaction: discord.Interaction, target: discord.Member | None = None):
            await interaction.response.defer()
            img_url = await fetch_waifu_image(name)
            await send_action_embed(interaction, action, img_url, target, emoji)
        return _command

    acciones_sfw = {
        "blush": ("se sonroja", "üòä"),
        "wink": ("gui√±a el ojo", "üòâ"),
        "pat": ("acaricia", "ü´∂"), "hug": ("abraza", "ü§ó"), "poke": ("toca", "üëà"),
        "smile": ("sonr√≠e", "üòÑ"), "wave": ("saluda", "üëã"), "highfive": ("choca los cinco", "üôå"),
        "handhold": ("toma la mano", "ü§ù"), "nom": ("muerde suavemente", "üç™"), "bite": ("muerde", "üòà"),
        "slap": ("da una bofetada", "üëã"), "pokekick": ("da una patada", "ü¶µ"), "happy": ("muestra felicidad", "üòÑ"),
        "cry": ("llora", "üò¢"), "dance": ("baila", "üíÉ"), "cuddle": ("acurruca", "ü´Ç"),
        "yeet": ("lanza", "ü™Å"), "kiss": ("besa", "üòò"), "waifu": ("muestra una waifu", "üíñ"),
        "neko": ("muestra una neko", "üê±"),
    }

    for nombre, (accion, emoji) in acciones_sfw.items():
        command_callback = create_sfw_command(nombre, accion, emoji)
        bot.tree.add_command(app_commands.Command(name=nombre, description=f"{accion.capitalize()}.", callback=command_callback))

    # --- Factory para comandos NSFW ---
    def create_nsfw_command(name: str, action: str, emoji: str):
        @app_commands.describe(target="Menciona a alguien (opcional)")
        async def _command(interaction: discord.Interaction, target: discord.Member | None = None):
            await interaction.response.defer()
            if not interaction.channel.is_nsfw():
                embed = discord.Embed(
                    title="üö´ Canal no permitido",
                    description="Este comando solo puede usarse en canales marcados como **NSFW**.",
                    color=discord.Color.red(),
                )
                await interaction.followup.send(embed=embed, ephemeral=True)
                return

            img_url = await fetch_waifu_image(name, nsfw=True)
            await send_nsfw_embed(interaction, action, img_url, target, emoji)
        return _command

    acciones_nsfw = {
        "waifu": ("muestra su lado NSFW", "üåô"),
        "neko": ("se transforma en neko sensual", "üêæ"),
        "blowjob": ("da un momento √≠ntimo intenso", "üí¶"),
    }

    for nombre, (accion, emoji) in acciones_nsfw.items():
        command_callback = create_nsfw_command(nombre, accion, emoji)
        command_name = f"nsfw_{nombre}"
        bot.tree.add_command(app_commands.Command(name=command_name, description=f"{accion.capitalize()} (solo canales NSFW).", callback=command_callback))

# ====== MISC ======
@bot.tree.command(name="sobremi", description="Muestra informaci√≥n sobre el bot.")
async def sobremi(interaction: discord.Interaction):
    embed = make_embed("Acerca de m√≠", color=discord.Color.random().value)
    embed.set_thumbnail(url=bot.user.avatar.url)
    embed.add_field(name="Nombre", value=bot.user.name, inline=True)
    embed.add_field(name="Creador", value="Beethoven", inline=True)
    embed.add_field(name="Lenguaje", value="Python 3.10+", inline=True)
    embed.add_field(name="Librer√≠a", value=f"discord.py {discord.__version__}", inline=True)
    embed.add_field(name="Servidores", value=len(bot.guilds), inline=True)
    embed.add_field(name="Usuarios (√∫nicos)", value=len({m.id for g in bot.guilds for m in g.members}), inline=True)
    embed.add_field(name="Comandos", value=len(bot.tree.get_commands()), inline=True)
    embed.set_footer(text="¬°Gracias por usar este software ^~^!")
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="invite", description="Enlace para invitar al bot.")
async def invite(interaction: discord.Interaction):
    embed = make_embed("¬°Inv√≠tame!", "Haz clic para invitarme.", color=discord.Color.green().value)
    embed.add_field(name="Enlace", value="[Invitar](https://discord.com/oauth2/authorize?client_id=872866276232540190&scope=bot&permissions=2147483647)", inline=False)
    embed.set_thumbnail(url="https://i.imgur.com/fu3yit1.png")
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="soporte", description="Servidor de soporte.")
async def soporte(interaction: discord.Interaction):
    embed = make_embed("Soporte", "√önete para ayuda.", color=discord.Color.blue().value)
    embed.add_field(name="Enlace", value="https://discord.gg/PvJNZQUQGf", inline=False)
    embed.set_footer(text="¬°√önete ahora!")
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="dev", description="Info sobre el desarrollador.")
async def creador(interaction: discord.Interaction):
    embed = make_embed("Informaci√≥n del desarrollador", "Hola, soy Beethoven, creador del bot.", color=0xff69b4)
    embed.set_thumbnail(url="https://cdn.discordapp.com/avatars/719366657558052944/0cc0749bb66fc9dabcc678983192f797.png?size=1024")
    embed.add_field(name="Usuario", value="Shangonomiya#2937", inline=False)
    embed.add_field(name="Lenguaje", value="Python con discord.py v2.x", inline=False)
    embed.add_field(name="Descripci√≥n", value="Bot para diversi√≥n y moderaci√≥n. En desarrollo con chatbot planeado.", inline=False)
    embed.add_field(name="Agradecimientos", value="A Whigrey y Hizer por ayuda.", inline=False)
    embed.add_field(name="Redes", value="[Twitter](https://twitter.com/S_Kitty05) [YouTube](https://www.youtube.com/channel/UCCawTLnpgbc7_ltyGScoQpw)", inline=False)
    embed.set_footer(text="En desarrollo, posibles errores.")
    await interaction.response.send_message(embed=embed)

from discord.ui import View, Button
from discord import Embed, Interaction
import discord

class TutorialView(View):
    def __init__(self):
        super().__init__(timeout=180)
        self.page = 0

        # P√°ginas del tutorial
        self.pages = [
            Embed(
                title="üìò Tutorial de /calc",
                description=(
                    "Bienvenido al **tutorial del comando `/cal`**.\n\n"
                    "Este comando te permite realizar **operaciones matem√°ticas** directamente desde Discord.\n"
                    "Usa expresiones simples o funciones avanzadas como si estuvieras en una calculadora cient√≠fica üßÆ."
                ),
                color=discord.Color.blurple()
            ),
            Embed(
                title="‚ûï Operaciones b√°sicas",
                description=(
                    "**Suma (+)** ‚Üí `2 + 3` = **5**\n"
                    "**Resta (-)** ‚Üí `8 - 4` = **4**\n"
                    "**Multiplicaci√≥n (*)** ‚Üí `6 * 7` = **42**\n"
                    "**Divisi√≥n (/)** ‚Üí `9 / 3` = **3.0**\n"
                    "**Potencia (^)** ‚Üí `2 ** 3` = **8**\n\n"
                    "üí° Consejo: Usa par√©ntesis para agrupar operaciones, ejemplo:\n"
                    "`(3 + 2) * 5` = **25**"
                ),
                color=discord.Color.green()
            ),
            Embed(
                title="üî¢ Funciones avanzadas",
                description=(
                    "Puedes usar **funciones matem√°ticas** del m√≥dulo `math`:\n\n"
                    "üìè `sqrt(x)` ‚Üí Ra√≠z cuadrada\n"
                    "üåÄ `sin(x)`, `cos(x)`, `tan(x)` ‚Üí Trigonometr√≠a (en radianes)\n"
                    "üìà `ln(x)` ‚Üí Logaritmo natural (base *e*)\n"
                    "üéØ `^(x, y)` ‚Üí Potencia de `x` elevado a `y`\n"
                    "Ejemplo: `sin(3.1416/2)` = **1.0**"
                ),
                color=discord.Color.orange()
            ).set_footer(
                text="Nota: No pudimos agregar algunos simbolos o funciones como 'rad,' 'pi,' o 'e' debido a las limitaciones de Discord. Sin embargo seguimos trabajando para poder agregar muchas mas funciones. "
                "" 
                "Siempre usa los parentesis '()' al usar funciones como sin o cos para obtener un resultado y evitar errores. \n"
            ),
            Embed(
                title="üí° Ejemplos pr√°cticos",
                description=(
                    "Aqu√≠ tienes algunos ejemplos listos para usar:\n\n"
                    "üîπ `/calculate expression: 2+2`\n"
                    "‚Üí **Resultado:** 4\n\n"
                    "üîπ `/calculate expression: sqrt(16)`\n"
                    "‚Üí **Resultado:** 4\n\n"
                    "üîπ `/calculate expression: sin(3.1416/2)`\n"
                    "‚Üí **Resultado:** 1.0\n\n"
                    "üöÄ ¬°Y listo! Ahora puedes usar `/calculate` para resolver cualquier expresi√≥n matem√°tica."
                ),
                color=discord.Color.purple()
            )
        ]

        self.add_item(PrevButton(self))
        self.add_item(NextButton(self))

class PrevButton(Button):
    def __init__(self, tutorial_view):
        super().__init__(label="‚è™ Anterior", style=discord.ButtonStyle.secondary)
        self.view_ref = tutorial_view

    async def callback(self, interaction: Interaction):
        self.view_ref.page = (self.view_ref.page - 1) % len(self.view_ref.pages)
        await interaction.response.edit_message(embed=self.view_ref.pages[self.view_ref.page], view=self.view_ref)

class NextButton(Button):
    def __init__(self, tutorial_view):
        super().__init__(label="Siguiente ‚è©", style=discord.ButtonStyle.secondary)
        self.view_ref = tutorial_view

    async def callback(self, interaction: Interaction):
        self.view_ref.page = (self.view_ref.page + 1) % len(self.view_ref.pages)
        await interaction.response.edit_message(embed=self.view_ref.pages[self.view_ref.page], view=self.view_ref)

@bot.tree.command(name="calculate_tutorial", description="Muestra un tutorial sobre c√≥mo usar el comando /calc.")
async def calculate_tutorial(interaction: Interaction):
    view = TutorialView()
    await interaction.response.send_message(embed=view.pages[0], view=view, ephemeral=False)


from discord.ui import View, Button, Select

# View principal de ayuda
class HelpView(View):
    def __init__(self, commands_list):
        super().__init__(timeout=120)
        self.commands_list = commands_list
        self.embed = discord.Embed(
            title="üìö Men√∫ de ayuda",
            description="Selecciona una categor√≠a para ver los comandos.",
            color=discord.Color.blurple()
        )
        self.embed.set_footer(text="Hola :D")

        # Categor√≠as definidas
        categories = {
            "Moderaci√≥n": [],
            "Utilidad": [],
            "Diversi√≥n": [],
            "Anime": [],
            "Interaccion": [],
            "Mas Interaccion": [],
            "NSFW": [],
            "Otros": []
        }

        for cmd in commands_list:
            cat = getattr(cmd, "category", None)
            if not cat:
                if cmd.name in ["ban", "kick", "unban", "purge", "blacklistadd", "blacklistremove"]:
                    cat = "Moderaci√≥n"
                elif cmd.name in ["ping", "userinfo", "serverinfo", "calculate", "qr", "avatar", "afk", "unafk", "calculate_tutorial"]:
                    cat = "Utilidad"
                elif cmd.name in ["nsfw_neko", "nsfw_waifu", "blowjob"]:
                    cat = "NSFW"
                elif cmd.name in ["hello", "say", "bola8", "rps", "guess"]:
                    cat = "Diversi√≥n"
                elif cmd.name in ["blush", "wink", "pat", "hug", "kiss", "poke", 'smile', 'wave', 'highfive', 'handhold', 'nom', 'bite']:
                        cat = "Interaccion"
                elif cmd.name in ['slap', 'kick', 'happy', 'cry', 'dance', 'cuddle', 'yeet', 'kiss', 'waifu', 'neko']:
                        cat = "Mas Interaccion" # 'kick' est√° duplicado, lo he renombrado a 'pokekick' en acciones_sfw
                elif cmd.name in ["aniinfo"]:  # agrega tus comandos de anime/im√°genes
                    cat = "Anime"
                else:
                    cat = "Otros"
            categories[cat].append(cmd)

        # Crear un bot√≥n por categor√≠a
        for cat_name, cmds in categories.items():
            if cmds:
                self.add_item(CategoryButton(cat_name, cmds))


# Bot√≥n por categor√≠a
class CategoryButton(Button):
    def __init__(self, category_name, cmds):
        super().__init__(label=category_name, style=discord.ButtonStyle.primary)
        self.cmds = cmds

    async def callback(self, interaction: discord.Interaction):
        cmds_per_page = 25
        total_pages = (len(self.cmds) - 1) // cmds_per_page + 1
        page = 0

        def get_options(page):
            start = page * cmds_per_page
            end = start + cmds_per_page
            return [
                discord.SelectOption(
                    label=cmd.name,
                    description=(cmd.description[:50] if cmd.description else "Sin descripci√≥n"),
                    value=cmd.name
                ) for cmd in sorted(self.cmds, key=lambda c: c.name)[start:end]
            ]

        options = get_options(page)
        select = Select(placeholder=f"Selecciona un comando de {self.label}", options=options)

        async def select_callback(select_interaction: discord.Interaction):
            cmd_name = select_interaction.data["values"][0]
            cmd = next(c for c in self.cmds if c.name == cmd_name)
            embed = discord.Embed(
                title=f"üõ†Ô∏è Ayuda: /{cmd.name}",
                description=cmd.description or "Sin descripci√≥n disponible.",
                color=discord.Color.orange()
            )
            # Mostrar argumentos del comando
            if hasattr(cmd, "parameters") and cmd.parameters:
                args_text = ""
                for param in cmd.parameters:
                    if hasattr(param, "name"):
                        args_text += f"`{param.name}`: {getattr(param, 'description', 'Sin descripci√≥n')}\n"
                if args_text:
                    embed.add_field(name="Argumentos", value=args_text, inline=False)
            await select_interaction.response.edit_message(embed=embed)

        select.callback = select_callback

        # Botones de paginaci√≥n
        view = View()
        view.add_item(select)

        if total_pages > 1:
            class PrevPage(Button):
                def __init__(self):
                    super().__init__(label="‚è™ Anterior", style=discord.ButtonStyle.secondary)
                async def callback(self, i):
                    nonlocal page
                    page = (page - 1) % total_pages
                    select.options = get_options(page)
                    await i.response.edit_message(view=view)

            class NextPage(Button):
                def __init__(self):
                    super().__init__(label="Siguiente ‚è©", style=discord.ButtonStyle.secondary)
                async def callback(self, i):
                    nonlocal page
                    page = (page + 1) % total_pages
                    select.options = get_options(page)
                    await i.response.edit_message(view=view)

            view.add_item(PrevPage())
            view.add_item(NextPage())

        await interaction.response.edit_message(embed=discord.Embed(title=f"üìñ {self.label}"), view=view)


# Comando de barra /help
@bot.tree.command(name="help", description="Muestra todos los comandos del bot categorizados.")
async def help_command(interaction: discord.Interaction):
    commands_list = bot.tree.get_commands()
    view = HelpView(commands_list)

    try:
        # Env√≠a el mensaje inicial
        await interaction.response.send_message(embed=view.embed, view=view, ephemeral=False)
    except discord.InteractionResponded:
        # Si ya fue respondido, usa followup
        await interaction.followup.send(embed=view.embed, view=view)


# ====== RUN ======
if __name__ == "__main__":
    setup_anime_commands(bot)
    keep_alive()
    try:
        bot.run(TOKEN)
    finally:
        # cerrar sesi√≥n http si existe al terminar
        if http_session and not http_session.closed:
            asyncio.run(http_session.close())
